#!/bin/bash
# tsyne - TypeScript native GUI runner with embedded dependency support
#
# Usage: tsyne [options] <app.ts>
#
# Runs Tsyne TypeScript applications, automatically resolving @grab dependencies.
#
# Example:
#   ./scripts/tsyne examples/weather-viewer-standalone.ts
#
# See docs/EMBEDDED_DEPENDENCIES.md for full documentation.

set -e

TSYNE_CACHE="${TSYNE_CACHE:-$HOME/.tsyne/packages}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Flags
DRY_RUN=false
UPDATE=false
OFFLINE=false
LIST_CACHE=false
CLEAR_CACHE=false
VERBOSE=false

usage() {
    echo "Usage: $(basename "$0") [options] <app.ts>"
    echo ""
    echo "Grapes-alike TypeScript runner - auto-installs @grab dependencies"
    echo ""
    echo "Options:"
    echo "  --dry-run     Show what would be installed without doing it"
    echo "  --update      Force update all dependencies"
    echo "  --offline     Run without installing (use cached only)"
    echo "  --list-cache  List all cached packages"
    echo "  --clear-cache Clear the package cache"
    echo "  --verbose     Show detailed output"
    echo "  --help        Show this help message"
    echo ""
    echo "Example:"
    echo "  $(basename "$0") examples/weather-viewer-standalone.ts"
    exit 0
}

log_info() {
    echo -e "${BLUE}[tsyne]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[tsyne]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[tsyne]${NC} $1"
}

log_error() {
    echo -e "${RED}[tsyne]${NC} $1"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --update)
            UPDATE=true
            shift
            ;;
        --offline)
            OFFLINE=true
            shift
            ;;
        --list-cache)
            LIST_CACHE=true
            shift
            ;;
        --clear-cache)
            CLEAR_CACHE=true
            shift
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --help|-h)
            usage
            ;;
        -*)
            log_error "Unknown option: $1"
            usage
            ;;
        *)
            SOURCE_FILE="$1"
            shift
            ;;
    esac
done

# Handle cache operations
if [ "$LIST_CACHE" = true ]; then
    if [ -d "$TSYNE_CACHE/node_modules" ]; then
        log_info "Packages in cache ($TSYNE_CACHE):"
        ls -1 "$TSYNE_CACHE/node_modules" 2>/dev/null | grep -v "^\." | while read pkg; do
            if [ -f "$TSYNE_CACHE/node_modules/$pkg/package.json" ]; then
                version=$(grep '"version"' "$TSYNE_CACHE/node_modules/$pkg/package.json" | head -1 | grep -oP ':\s*"\K[^"]+')
                echo "  - $pkg@$version"
            else
                echo "  - $pkg"
            fi
        done
    else
        log_info "Cache is empty"
    fi
    exit 0
fi

if [ "$CLEAR_CACHE" = true ]; then
    log_warn "Clearing cache at $TSYNE_CACHE"
    rm -rf "$TSYNE_CACHE"
    log_success "Cache cleared"
    exit 0
fi

# Require source file for running
if [ -z "$SOURCE_FILE" ]; then
    log_error "No source file specified"
    usage
fi

if [ ! -f "$SOURCE_FILE" ]; then
    log_error "File not found: $SOURCE_FILE"
    exit 1
fi

# Parse @Grab directives
# Format: // @Grab('package@version')
log_info "Parsing @Grab directives from $SOURCE_FILE..."

# Extract package@version strings, then split them
# Pattern matches: // @Grab('package@version')
GRAB_SPECS=$(grep -oP "// @Grab\('\K[^']+(?='\))" "$SOURCE_FILE" 2>/dev/null || true)

if [ -z "$GRAB_SPECS" ]; then
    log_info "No @Grab directives found, running directly..."
else
    # Convert to arrays and split package@version
    readarray -t SPECS <<< "$GRAB_SPECS"
    PACKAGES=()
    VERS=()
    for spec in "${SPECS[@]}"; do
        # Split on @ - package is before @, version is after
        pkg="${spec%@*}"
        ver="${spec#*@}"
        PACKAGES+=("$pkg")
        VERS+=("$ver")
    done

    log_info "Found ${#PACKAGES[@]} dependencies:"
    for i in "${!PACKAGES[@]}"; do
        echo "  - ${PACKAGES[$i]}@${VERS[$i]}"
    done

    if [ "$DRY_RUN" = true ]; then
        log_info "Dry run - no packages will be installed"
        exit 0
    fi

    if [ "$OFFLINE" = true ]; then
        log_warn "Offline mode - using cached packages only"
    else
        # Ensure cache directory exists
        mkdir -p "$TSYNE_CACHE"

        # Initialize package.json if needed
        if [ ! -f "$TSYNE_CACHE/package.json" ]; then
            log_info "Initializing package cache..."
            (cd "$TSYNE_CACHE" && npm init -y > /dev/null 2>&1)
        fi

        # Install each package
        for i in "${!PACKAGES[@]}"; do
            pkg="${PACKAGES[$i]}"
            ver="${VERS[$i]}"
            pkg_dir="$TSYNE_CACHE/node_modules/$pkg"

            needs_install=false

            if [ ! -d "$pkg_dir" ]; then
                needs_install=true
            elif [ "$UPDATE" = true ]; then
                needs_install=true
            fi

            if [ "$needs_install" = true ]; then
                log_info "Installing $pkg@$ver..."
                if [ "$VERBOSE" = true ]; then
                    (cd "$TSYNE_CACHE" && npm install "$pkg@$ver")
                else
                    (cd "$TSYNE_CACHE" && npm install "$pkg@$ver" > /dev/null 2>&1)
                fi
                log_success "Installed $pkg@$ver"
            else
                [ "$VERBOSE" = true ] && log_info "Using cached $pkg"
            fi
        done
    fi
fi

# Ensure tsyne-bridge is built
BRIDGE_PATH="$PROJECT_ROOT/bin/tsyne-bridge"
if [ ! -f "$BRIDGE_PATH" ]; then
    log_warn "tsyne-bridge not found at $BRIDGE_PATH"
    log_info "Building bridge..."
    (cd "$PROJECT_ROOT/bridge" && go build -o "$BRIDGE_PATH")
    log_success "Bridge built"
fi

# Run the application with NODE_PATH including our cache
log_info "Starting application..."
echo ""

# Build NODE_PATH - include cache, project node_modules, and existing NODE_PATH
EFFECTIVE_NODE_PATH="$TSYNE_CACHE/node_modules:$PROJECT_ROOT/node_modules"
if [ -n "$NODE_PATH" ]; then
    EFFECTIVE_NODE_PATH="$EFFECTIVE_NODE_PATH:$NODE_PATH"
fi

# Run with ts-node
NODE_PATH="$EFFECTIVE_NODE_PATH" npx ts-node "$SOURCE_FILE"
